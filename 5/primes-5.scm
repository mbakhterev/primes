(define (make-ones N) (1- (logbit1 N 0)))

(define (init-marks N) (assert (fx> N 1)) (logxor (make-ones N) #b11))

(define (sieve M N p cursor) 
  (let loop ((m M) (c cursor))
    (if (fx< c N)
        (loop (logbit0 c m) (fx+ c p))
        (values m (fx- c N)))))

(define (next-prime-offset M N start)
  (let ((s (fx+ start 1 (fxlogand start 1))))
    (if (fx< s N)
      (let ((bit (bitwise-first-bit-set (bitwise-bit-field M s N))))
        (if (fxnonnegative? bit) (fx+ bit s) N))
      N)))

(define (count-marks M N)
  (let loop ((i 0) (s 0))
    (if (fx< i N) (loop (fx1+ i) (if (logbit? i M) (fx1+ s) s)) s)))

; (bitwise-bit-count (bitwise-bit-field M 0 N))

(define (compactify primes cursors n)
  (let ((prime-vector (make-fxvector n))
        (cursor-vector (make-fxvector n)))
    (let loop ((i (fx1- n))
               (P primes)
               (C cursors))
      (if (pair? P)
        (begin (fxvector-set! prime-vector i (car P))
               (fxvector-set! cursor-vector i (car C))
               (loop (fx1- i) (cdr P) (cdr C)))
        (values (fxvector->immutable-fxvector prime-vector) cursor-vector)))))

(define (optimus-primes N)
  (let loop ((M (if (fx< N 2) 0 (init-marks N)))
             (p 2)
             (n 0)
             (P '())
             (C '()))
    (if (fx< p N)
      (let-values (((next-M c) (sieve M N p (+ p p))))
        (loop next-M
              (next-prime-offset M N p)
              (fx1+ n)
              (cons p P)
              (cons c C)))
      (compactify P C n))))

(define (sieve-recursor-count N P C)
  (let ((l (fxvector-length P)))
    (let loop ((i 0)
               (M (make-ones N)))
      (if (fx< i l)
          (let ((p (fxvector-ref P i))
                (c (fxvector-ref C i)))
            (let-values (((next-M next-c) (sieve M N p c)))
              (fxvector-set! C i next-c)
              (loop (fx1+ i) next-M)))
          (count-marks M N)))))

(define (go N)
  (let ((L (fx1+ (isqrt N))))
    (let-values (((P C) (optimus-primes L)))
      (if (fxzero? (fxvector-length P))
          0
          (let loop ((n (fxvector-length P))
                     (l (fx- (fx1+ N) L)))
            (if (fxpositive? l)
                (loop (fx+ n (sieve-recursor-count (fxmin l L) P C)) (fx- l L))
                n))))))

(display (go (string->number (cadr (command-line))))) (newline)
