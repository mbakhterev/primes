(define (dump v) (display v) (newline))

(define (init-marks L)
  (assert (fx> L 1))
    (let ((B (1- (logbit1 (fx1+ L) 0))))
      (dump B)
      (logxor B #b11)))

(define (marks-limit V L) (fxmin L (fx1- (bitwise-length V))))

(define (sieve M limit p cursor)
  (let ((l (marks-limit M limit)))
    (let loop ((m M) (c cursor))
      (if (fx<= c l)
        (loop (logbit0 c m) (fx+ c p))
        (values m (fx- c l 1))))))

(define (next-prime-offset M limit start)
  (let ((l (marks-limit M limit start))
        (s (fx+ start 1 (fxlogand start 1))))
    (let ((p (fx+ s (bitwise-first-bit-set (bitwise-bit-field m s (fx1+ limit))))))
      (if (fxpositive? p)
        p
        (fx1+ limit)))))

(define (count-marks M L) (bitwise-bit-count (bitwise-bit-field M 0 (fx1+ L))))

(define (compactify primes cursors n)
  (let ((prime-vector (make-fxvector n))
        (cursor-vector (make-fxvector n)))
    (let loop ((i (fx1- n))
               (P primes)
               (C cursors))
      (if (pair? P)
        (begin (fxvector-set! prime-vector i (car P))
               (fxvector-set! cursor-vector i (car C))
               (loop (fx1- i) (cdr P) (cdr C)))
        (values (fxvector->immutable-fxvector prime-vector) cursor-vector)))))

(define (optimus-primes N)
  (let ((L (isqrt N)))
    (let loop ((M (if (< L 2) 0 (init-marks L)))
               (p 2)
               (n 0)
               (P '())
               (C '()))
      (if (fx<= p L)
        (let-values (((next-M c) (sieve M N p (+ p p))))
          (loop next-M (fx1+ n) (cons p P) (cons c C)))
        (let-values (((primes cursors) (compactify P C n)))
          (values M primes counts))))))

(define (go N)
  (let ((M (init-marks (isqrt N))))
      (format #t "~a ~b ~a~%" N M (bitwise-length M))
    )
  )

(go (string->number (cadr (command-line))))
