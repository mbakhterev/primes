(define (dump v) (display v) (newline))

(define (init-markvector L)
  (assert (fx> L 1))
  (let ((M (make-bytevector (fx1+ L) 1)))
    (bytevector-u8-set! M 0 0)
    (bytevector-u8-set! M 1 0)
    M))

(define (marks-limit V N) (fxmin N (bytevector-length V)))

(define (sieve! M N p cursor)
  (let ((L (marks-limit M N) ))
    (let loop ((c cursor))
      (if (fx< c L)
          (begin (bytevector-u8-set! M c 0)
                 (loop (fx+ c p)))
          (fx- c L)))))

(define (next-prime-offset M N start)
  (let ((L (marks-limit M N)))
    (let loop ((i (fx+ start 1 (fxlogand start 1))))
      (or (and (fx< i L)
               (fxzero? (bytevector-u8-ref M i))
               (loop (fx+ 2 i)))
          i))))

(define (sum V N)
  (let ((L (marks-limit V N)))
    (let loop ((i 0) (s 0))
      (if (fx< i L)
        (loop (fx1+ i) (fx+ s (bytevector-u8-ref V i)))
        s))))

(define (compactify primes cursors n)
  (let ((prime-vector (make-fxvector n))
        (cursor-vector (make-fxvector n)))
    (let loop ((i (fx1- n))
               (P primes)
               (C cursors))
      (if (pair? P)
        (begin (fxvector-set! prime-vector i (car P))
               (fxvector-set! cursor-vector i (car C))
               (loop (fx1- i) (cdr P) (cdr C)))
        (values (fxvector->immutable-fxvector prime-vector) cursor-vector)))))

(define (optimus-primes L)
  (let* ((M ((if (< L 2) make-bytevector init-markvector) L))
         (l (bytevector-length M)))
    (let loop ((p 2)
               (n 0)
               (P '())
               (C '()))
      (if (fx< p l)
        (loop (next-prime-offset M l p)
              (fx1+ n)
              (cons p P)
              (cons (sieve! M l p (+ p p)) C))
        (let-values (((primes cursors) (compactify P C n)))
;           (dump M)
;           (dump primes)
          (values M primes cursors))))))

(define (sieve-recursor-count! N M P C)
  (bytevector-fill! M 1)
  (let ((l (fxvector-length P)))
    (let loop ((i 0))
      (if (fx< i l)
        (let ((p (fxvector-ref P i))
              (c (fxvector-ref C i)))
          (fxvector-set! C i (sieve! M N p c))
          (loop (fx1+ i)))
        (sum M N)))))

(define (go N)
  (let-values (((M P C) (optimus-primes (isqrt N))))
    (if (fxzero? (fxvector-length P))
        (dump 0)
        (let ((L (bytevector-length M)))
          (let loop ((n (fxvector-length P))
                     (left (- (fx1+ N) L)))
            (if (fxpositive? left)
                (loop (fx+ n (sieve-recursor-count! left M P C)) (- left L))
                (dump n)))))))

(go (string->number (cadr (command-line))))
